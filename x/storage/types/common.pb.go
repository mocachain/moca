// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: moca/storage/common.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SourceType represents the source of resource creation, which can
// from Moca native or from a cross-chain transfer from BSC
type SourceType int32

const (
	SOURCE_TYPE_ORIGIN               SourceType = 0
	SOURCE_TYPE_MIRROR_PENDING       SourceType = 1
	SOURCE_TYPE_BSC_CROSS_CHAIN      SourceType = 2
	SOURCE_TYPE_OP_CROSS_CHAIN       SourceType = 3
	SOURCE_TYPE_POLYGON_CROSS_CHAIN  SourceType = 4
	SOURCE_TYPE_SCROLL_CROSS_CHAIN   SourceType = 5
	SOURCE_TYPE_LINEA_CROSS_CHAIN    SourceType = 6
	SOURCE_TYPE_MANTLE_CROSS_CHAIN   SourceType = 7
	SOURCE_TYPE_ARBITRUM_CROSS_CHAIN SourceType = 8
	SOURCE_TYPE_OPTIMISM_CROSS_CHAIN SourceType = 9
	SOURCE_TYPE_BASE_CROSS_CHAIN     SourceType = 10
)

var SourceType_name = map[int32]string{
	0:  "SOURCE_TYPE_ORIGIN",
	1:  "SOURCE_TYPE_MIRROR_PENDING",
	2:  "SOURCE_TYPE_BSC_CROSS_CHAIN",
	3:  "SOURCE_TYPE_OP_CROSS_CHAIN",
	4:  "SOURCE_TYPE_POLYGON_CROSS_CHAIN",
	5:  "SOURCE_TYPE_SCROLL_CROSS_CHAIN",
	6:  "SOURCE_TYPE_LINEA_CROSS_CHAIN",
	7:  "SOURCE_TYPE_MANTLE_CROSS_CHAIN",
	8:  "SOURCE_TYPE_ARBITRUM_CROSS_CHAIN",
	9:  "SOURCE_TYPE_OPTIMISM_CROSS_CHAIN",
	10: "SOURCE_TYPE_BASE_CROSS_CHAIN",
}

var SourceType_value = map[string]int32{
	"SOURCE_TYPE_ORIGIN":               0,
	"SOURCE_TYPE_MIRROR_PENDING":       1,
	"SOURCE_TYPE_BSC_CROSS_CHAIN":      2,
	"SOURCE_TYPE_OP_CROSS_CHAIN":       3,
	"SOURCE_TYPE_POLYGON_CROSS_CHAIN":  4,
	"SOURCE_TYPE_SCROLL_CROSS_CHAIN":   5,
	"SOURCE_TYPE_LINEA_CROSS_CHAIN":    6,
	"SOURCE_TYPE_MANTLE_CROSS_CHAIN":   7,
	"SOURCE_TYPE_ARBITRUM_CROSS_CHAIN": 8,
	"SOURCE_TYPE_OPTIMISM_CROSS_CHAIN": 9,
	"SOURCE_TYPE_BASE_CROSS_CHAIN":     10,
}

func (x SourceType) String() string {
	return proto.EnumName(SourceType_name, int32(x))
}

func (SourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{0}
}

// BucketStatus represents the status of a bucket. After a user successfully
// sends a CreateBucket transaction onto the chain, the status is set to 'Created'.
// When a Discontinue Object transaction is received on chain, the status is set to 'Discontinued'.
type BucketStatus int32

const (
	BUCKET_STATUS_CREATED      BucketStatus = 0
	BUCKET_STATUS_DISCONTINUED BucketStatus = 1
	BUCKET_STATUS_MIGRATING    BucketStatus = 2
)

var BucketStatus_name = map[int32]string{
	0: "BUCKET_STATUS_CREATED",
	1: "BUCKET_STATUS_DISCONTINUED",
	2: "BUCKET_STATUS_MIGRATING",
}

var BucketStatus_value = map[string]int32{
	"BUCKET_STATUS_CREATED":      0,
	"BUCKET_STATUS_DISCONTINUED": 1,
	"BUCKET_STATUS_MIGRATING":    2,
}

func (x BucketStatus) String() string {
	return proto.EnumName(BucketStatus_name, int32(x))
}

func (BucketStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{1}
}

// RedundancyType represents the redundancy algorithm type for object data,
// which can be either multi-replica or erasure coding.
type RedundancyType int32

const (
	REDUNDANCY_EC_TYPE      RedundancyType = 0
	REDUNDANCY_REPLICA_TYPE RedundancyType = 1
)

var RedundancyType_name = map[int32]string{
	0: "REDUNDANCY_EC_TYPE",
	1: "REDUNDANCY_REPLICA_TYPE",
}

var RedundancyType_value = map[string]int32{
	"REDUNDANCY_EC_TYPE":      0,
	"REDUNDANCY_REPLICA_TYPE": 1,
}

func (x RedundancyType) String() string {
	return proto.EnumName(RedundancyType_name, int32(x))
}

func (RedundancyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{2}
}

// ObjectStatus represents the creation status of an object. After a user successfully
// sends a CreateObject transaction onto the chain, the status is set to 'Created'.
// After the Primary Service Provider successfully sends a Seal Object transaction onto
// the chain, the status is set to 'Sealed'. When a Discontinue Object transaction is
// received on chain, the status is set to 'Discontinued'.
type ObjectStatus int32

const (
	OBJECT_STATUS_CREATED      ObjectStatus = 0
	OBJECT_STATUS_SEALED       ObjectStatus = 1
	OBJECT_STATUS_DISCONTINUED ObjectStatus = 2
)

var ObjectStatus_name = map[int32]string{
	0: "OBJECT_STATUS_CREATED",
	1: "OBJECT_STATUS_SEALED",
	2: "OBJECT_STATUS_DISCONTINUED",
}

var ObjectStatus_value = map[string]int32{
	"OBJECT_STATUS_CREATED":      0,
	"OBJECT_STATUS_SEALED":       1,
	"OBJECT_STATUS_DISCONTINUED": 2,
}

func (x ObjectStatus) String() string {
	return proto.EnumName(ObjectStatus_name, int32(x))
}

func (ObjectStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{3}
}

// VisibilityType is the resources public status.
type VisibilityType int32

const (
	VISIBILITY_TYPE_UNSPECIFIED VisibilityType = 0
	VISIBILITY_TYPE_PUBLIC_READ VisibilityType = 1
	VISIBILITY_TYPE_PRIVATE     VisibilityType = 2
	// If the bucket Visibility is inherit, it's finally set to private. If the object Visibility is inherit, it's the same as bucket.
	VISIBILITY_TYPE_INHERIT VisibilityType = 3
)

var VisibilityType_name = map[int32]string{
	0: "VISIBILITY_TYPE_UNSPECIFIED",
	1: "VISIBILITY_TYPE_PUBLIC_READ",
	2: "VISIBILITY_TYPE_PRIVATE",
	3: "VISIBILITY_TYPE_INHERIT",
}

var VisibilityType_value = map[string]int32{
	"VISIBILITY_TYPE_UNSPECIFIED": 0,
	"VISIBILITY_TYPE_PUBLIC_READ": 1,
	"VISIBILITY_TYPE_PRIVATE":     2,
	"VISIBILITY_TYPE_INHERIT":     3,
}

func (x VisibilityType) String() string {
	return proto.EnumName(VisibilityType_name, int32(x))
}

func (VisibilityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{4}
}

// SecondarySpSealObjectSignDoc used to generate seal signature of secondary SP
// If the secondary SP only signs the checksum to declare the object pieces are saved,
// it might be reused by the primary SP to fake it's declaration.
// Then the primary SP can challenge and slash the secondary SP.
// So the id of the object is needed to prevent this.
type SecondarySpSealObjectSignDoc struct {
	ChainId              string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	GlobalVirtualGroupId uint32 `protobuf:"varint,2,opt,name=global_virtual_group_id,json=globalVirtualGroupId,proto3" json:"global_virtual_group_id,omitempty"`
	ObjectId             Uint   `protobuf:"bytes,3,opt,name=object_id,json=objectId,proto3,customtype=Uint" json:"object_id"`
	// checksum is the sha256 hash of slice of integrity hash from secondary sps
	Checksum []byte `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
}

func (m *SecondarySpSealObjectSignDoc) Reset()         { *m = SecondarySpSealObjectSignDoc{} }
func (m *SecondarySpSealObjectSignDoc) String() string { return proto.CompactTextString(m) }
func (*SecondarySpSealObjectSignDoc) ProtoMessage()    {}
func (*SecondarySpSealObjectSignDoc) Descriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{0}
}
func (m *SecondarySpSealObjectSignDoc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondarySpSealObjectSignDoc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecondarySpSealObjectSignDoc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecondarySpSealObjectSignDoc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondarySpSealObjectSignDoc.Merge(m, src)
}
func (m *SecondarySpSealObjectSignDoc) XXX_Size() int {
	return m.Size()
}
func (m *SecondarySpSealObjectSignDoc) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondarySpSealObjectSignDoc.DiscardUnknown(m)
}

var xxx_messageInfo_SecondarySpSealObjectSignDoc proto.InternalMessageInfo

func (m *SecondarySpSealObjectSignDoc) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SecondarySpSealObjectSignDoc) GetGlobalVirtualGroupId() uint32 {
	if m != nil {
		return m.GlobalVirtualGroupId
	}
	return 0
}

func (m *SecondarySpSealObjectSignDoc) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

type GVGMapping struct {
	SrcGlobalVirtualGroupId uint32 `protobuf:"varint,1,opt,name=src_global_virtual_group_id,json=srcGlobalVirtualGroupId,proto3" json:"src_global_virtual_group_id,omitempty"`
	DstGlobalVirtualGroupId uint32 `protobuf:"varint,2,opt,name=dst_global_virtual_group_id,json=dstGlobalVirtualGroupId,proto3" json:"dst_global_virtual_group_id,omitempty"`
	SecondarySpBlsSignature []byte `protobuf:"bytes,3,opt,name=secondary_sp_bls_signature,json=secondarySpBlsSignature,proto3" json:"secondary_sp_bls_signature,omitempty"`
}

func (m *GVGMapping) Reset()         { *m = GVGMapping{} }
func (m *GVGMapping) String() string { return proto.CompactTextString(m) }
func (*GVGMapping) ProtoMessage()    {}
func (*GVGMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{1}
}
func (m *GVGMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GVGMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GVGMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GVGMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GVGMapping.Merge(m, src)
}
func (m *GVGMapping) XXX_Size() int {
	return m.Size()
}
func (m *GVGMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_GVGMapping.DiscardUnknown(m)
}

var xxx_messageInfo_GVGMapping proto.InternalMessageInfo

func (m *GVGMapping) GetSrcGlobalVirtualGroupId() uint32 {
	if m != nil {
		return m.SrcGlobalVirtualGroupId
	}
	return 0
}

func (m *GVGMapping) GetDstGlobalVirtualGroupId() uint32 {
	if m != nil {
		return m.DstGlobalVirtualGroupId
	}
	return 0
}

func (m *GVGMapping) GetSecondarySpBlsSignature() []byte {
	if m != nil {
		return m.SecondarySpBlsSignature
	}
	return nil
}

type SecondarySpMigrationBucketSignDoc struct {
	ChainId                 string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	DstPrimarySpId          uint32 `protobuf:"varint,2,opt,name=dst_primary_sp_id,json=dstPrimarySpId,proto3" json:"dst_primary_sp_id,omitempty"`
	SrcGlobalVirtualGroupId uint32 `protobuf:"varint,3,opt,name=src_global_virtual_group_id,json=srcGlobalVirtualGroupId,proto3" json:"src_global_virtual_group_id,omitempty"`
	DstGlobalVirtualGroupId uint32 `protobuf:"varint,4,opt,name=dst_global_virtual_group_id,json=dstGlobalVirtualGroupId,proto3" json:"dst_global_virtual_group_id,omitempty"`
	BucketId                Uint   `protobuf:"bytes,5,opt,name=bucket_id,json=bucketId,proto3,customtype=Uint" json:"bucket_id"`
}

func (m *SecondarySpMigrationBucketSignDoc) Reset()         { *m = SecondarySpMigrationBucketSignDoc{} }
func (m *SecondarySpMigrationBucketSignDoc) String() string { return proto.CompactTextString(m) }
func (*SecondarySpMigrationBucketSignDoc) ProtoMessage()    {}
func (*SecondarySpMigrationBucketSignDoc) Descriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{2}
}
func (m *SecondarySpMigrationBucketSignDoc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondarySpMigrationBucketSignDoc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecondarySpMigrationBucketSignDoc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecondarySpMigrationBucketSignDoc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondarySpMigrationBucketSignDoc.Merge(m, src)
}
func (m *SecondarySpMigrationBucketSignDoc) XXX_Size() int {
	return m.Size()
}
func (m *SecondarySpMigrationBucketSignDoc) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondarySpMigrationBucketSignDoc.DiscardUnknown(m)
}

var xxx_messageInfo_SecondarySpMigrationBucketSignDoc proto.InternalMessageInfo

func (m *SecondarySpMigrationBucketSignDoc) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SecondarySpMigrationBucketSignDoc) GetDstPrimarySpId() uint32 {
	if m != nil {
		return m.DstPrimarySpId
	}
	return 0
}

func (m *SecondarySpMigrationBucketSignDoc) GetSrcGlobalVirtualGroupId() uint32 {
	if m != nil {
		return m.SrcGlobalVirtualGroupId
	}
	return 0
}

func (m *SecondarySpMigrationBucketSignDoc) GetDstGlobalVirtualGroupId() uint32 {
	if m != nil {
		return m.DstGlobalVirtualGroupId
	}
	return 0
}

// Local virtual group(LVG) uniquely associated with a global virtual group.
// Each bucket maintains a mapping from local virtual group to global virtual group
// Each local virtual group is associated with a unique virtual payment account,
// where all object fees are streamed to.
type LocalVirtualGroup struct {
	// id is the identifier of the local virtual group.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// global_virtual_group_id is the identifier of the global virtual group.
	GlobalVirtualGroupId uint32 `protobuf:"varint,2,opt,name=global_virtual_group_id,json=globalVirtualGroupId,proto3" json:"global_virtual_group_id,omitempty"`
	// stored_size is the size of the stored data in the local virtual group.
	StoredSize uint64 `protobuf:"varint,3,opt,name=stored_size,json=storedSize,proto3" json:"stored_size,omitempty"`
	// total_charge_size is the total charged size of the objects in the LVG.
	// Notice that the minimum unit of charge is 128K
	TotalChargeSize uint64 `protobuf:"varint,4,opt,name=total_charge_size,json=totalChargeSize,proto3" json:"total_charge_size,omitempty"`
}

func (m *LocalVirtualGroup) Reset()         { *m = LocalVirtualGroup{} }
func (m *LocalVirtualGroup) String() string { return proto.CompactTextString(m) }
func (*LocalVirtualGroup) ProtoMessage()    {}
func (*LocalVirtualGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{3}
}
func (m *LocalVirtualGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalVirtualGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalVirtualGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalVirtualGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalVirtualGroup.Merge(m, src)
}
func (m *LocalVirtualGroup) XXX_Size() int {
	return m.Size()
}
func (m *LocalVirtualGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalVirtualGroup.DiscardUnknown(m)
}

var xxx_messageInfo_LocalVirtualGroup proto.InternalMessageInfo

func (m *LocalVirtualGroup) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LocalVirtualGroup) GetGlobalVirtualGroupId() uint32 {
	if m != nil {
		return m.GlobalVirtualGroupId
	}
	return 0
}

func (m *LocalVirtualGroup) GetStoredSize() uint64 {
	if m != nil {
		return m.StoredSize
	}
	return 0
}

func (m *LocalVirtualGroup) GetTotalChargeSize() uint64 {
	if m != nil {
		return m.TotalChargeSize
	}
	return 0
}

type BucketFlowRateLimit struct {
	// flow_rate_limit defines the flow rate limit of the bucket
	FlowRateLimit cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=flow_rate_limit,json=flowRateLimit,proto3,customtype=cosmossdk.io/math.Int" json:"flow_rate_limit"`
}

func (m *BucketFlowRateLimit) Reset()         { *m = BucketFlowRateLimit{} }
func (m *BucketFlowRateLimit) String() string { return proto.CompactTextString(m) }
func (*BucketFlowRateLimit) ProtoMessage()    {}
func (*BucketFlowRateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{4}
}
func (m *BucketFlowRateLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketFlowRateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketFlowRateLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketFlowRateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketFlowRateLimit.Merge(m, src)
}
func (m *BucketFlowRateLimit) XXX_Size() int {
	return m.Size()
}
func (m *BucketFlowRateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketFlowRateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_BucketFlowRateLimit proto.InternalMessageInfo

type BucketFlowRateLimitStatus struct {
	// is_bucket_limited defines the flow rate limit status of the bucket, true means limited and the bucket is uncharged
	IsBucketLimited bool `protobuf:"varint,1,opt,name=is_bucket_limited,json=isBucketLimited,proto3" json:"is_bucket_limited,omitempty"`
	// payment_address is the payment address of the bucket which limited the flow rate
	PaymentAddress string `protobuf:"bytes,2,opt,name=payment_address,json=paymentAddress,proto3" json:"payment_address,omitempty"`
}

func (m *BucketFlowRateLimitStatus) Reset()         { *m = BucketFlowRateLimitStatus{} }
func (m *BucketFlowRateLimitStatus) String() string { return proto.CompactTextString(m) }
func (*BucketFlowRateLimitStatus) ProtoMessage()    {}
func (*BucketFlowRateLimitStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bdd92b5b4d6cf45d, []int{5}
}
func (m *BucketFlowRateLimitStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketFlowRateLimitStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketFlowRateLimitStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketFlowRateLimitStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketFlowRateLimitStatus.Merge(m, src)
}
func (m *BucketFlowRateLimitStatus) XXX_Size() int {
	return m.Size()
}
func (m *BucketFlowRateLimitStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketFlowRateLimitStatus.DiscardUnknown(m)
}

var xxx_messageInfo_BucketFlowRateLimitStatus proto.InternalMessageInfo

func (m *BucketFlowRateLimitStatus) GetIsBucketLimited() bool {
	if m != nil {
		return m.IsBucketLimited
	}
	return false
}

func (m *BucketFlowRateLimitStatus) GetPaymentAddress() string {
	if m != nil {
		return m.PaymentAddress
	}
	return ""
}

func init() {
	proto.RegisterEnum("moca.storage.SourceType", SourceType_name, SourceType_value)
	proto.RegisterEnum("moca.storage.BucketStatus", BucketStatus_name, BucketStatus_value)
	proto.RegisterEnum("moca.storage.RedundancyType", RedundancyType_name, RedundancyType_value)
	proto.RegisterEnum("moca.storage.ObjectStatus", ObjectStatus_name, ObjectStatus_value)
	proto.RegisterEnum("moca.storage.VisibilityType", VisibilityType_name, VisibilityType_value)
	proto.RegisterType((*SecondarySpSealObjectSignDoc)(nil), "moca.storage.SecondarySpSealObjectSignDoc")
	proto.RegisterType((*GVGMapping)(nil), "moca.storage.GVGMapping")
	proto.RegisterType((*SecondarySpMigrationBucketSignDoc)(nil), "moca.storage.SecondarySpMigrationBucketSignDoc")
	proto.RegisterType((*LocalVirtualGroup)(nil), "moca.storage.LocalVirtualGroup")
	proto.RegisterType((*BucketFlowRateLimit)(nil), "moca.storage.BucketFlowRateLimit")
	proto.RegisterType((*BucketFlowRateLimitStatus)(nil), "moca.storage.BucketFlowRateLimitStatus")
}

func init() { proto.RegisterFile("moca/storage/common.proto", fileDescriptor_bdd92b5b4d6cf45d) }

var fileDescriptor_bdd92b5b4d6cf45d = []byte{
	// 1046 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x17, 0x15, 0x65, 0x25, 0xb1, 0x27, 0x8e, 0x2d, 0xf3, 0x73, 0x3e, 0xdb, 0x72, 0x2a, 0x29, 0x6a,
	0x17, 0xae, 0x81, 0x58, 0xfd, 0x41, 0x57, 0x4d, 0x16, 0x24, 0xc5, 0x28, 0xd3, 0x50, 0xa4, 0x30,
	0xa4, 0x8c, 0xba, 0x9b, 0x01, 0x45, 0x32, 0xf4, 0xd4, 0x24, 0x47, 0xe0, 0x8c, 0x9c, 0x3a, 0x4f,
	0xd0, 0x76, 0x55, 0xf4, 0x15, 0x5a, 0xa0, 0x5d, 0x76, 0x91, 0x57, 0x28, 0x10, 0xa0, 0x9b, 0x20,
	0xab, 0xa2, 0x8b, 0xa0, 0xb0, 0x17, 0x7d, 0x8d, 0x82, 0x1c, 0xda, 0x15, 0x5d, 0xd5, 0x08, 0xda,
	0x0d, 0xa1, 0xb9, 0xe7, 0xdc, 0x7b, 0xcf, 0x3d, 0x77, 0x24, 0x0a, 0x6c, 0xc5, 0xd4, 0x73, 0xbb,
	0x8c, 0xd3, 0xd4, 0x0d, 0x83, 0xae, 0x47, 0xe3, 0x98, 0x26, 0x7b, 0x93, 0x94, 0x72, 0x2a, 0x2f,
	0x67, 0xd0, 0x5e, 0x01, 0x35, 0xd6, 0xdc, 0x98, 0x24, 0xb4, 0x9b, 0x3f, 0x05, 0xa1, 0xb1, 0xe5,
	0x51, 0x16, 0x53, 0x86, 0xf3, 0x53, 0x57, 0x1c, 0x0a, 0x68, 0x3d, 0xa4, 0x21, 0x15, 0xf1, 0xec,
	0x93, 0x88, 0x76, 0x7e, 0x91, 0xc0, 0x1d, 0x3b, 0xf0, 0x68, 0xe2, 0xbb, 0xe9, 0x89, 0x3d, 0xb1,
	0x03, 0x37, 0xb2, 0xc6, 0x9f, 0x07, 0x1e, 0xb7, 0x49, 0x98, 0xf4, 0xa8, 0x27, 0x6f, 0x81, 0x45,
	0xef, 0xd0, 0x25, 0x09, 0x26, 0xfe, 0xa6, 0xd4, 0x96, 0x76, 0x96, 0xd0, 0x8d, 0xfc, 0x0c, 0x7d,
	0xf9, 0x23, 0xb0, 0x11, 0x46, 0x74, 0xec, 0x46, 0xf8, 0x98, 0xa4, 0x7c, 0xea, 0x46, 0x38, 0x4c,
	0xe9, 0x74, 0x92, 0x31, 0xab, 0x6d, 0x69, 0xe7, 0x16, 0x5a, 0x17, 0xf0, 0xbe, 0x40, 0xfb, 0x19,
	0x08, 0x7d, 0xf9, 0x01, 0x58, 0xa2, 0x79, 0x8b, 0x8c, 0xb8, 0x90, 0x95, 0x54, 0xdb, 0x2f, 0x5e,
	0xb7, 0x2a, 0xbf, 0xbd, 0x6e, 0xd5, 0x46, 0x24, 0xe1, 0xaf, 0x9e, 0xdf, 0xbb, 0x59, 0x28, 0xcf,
	0x8e, 0x3f, 0xfe, 0xf1, 0xd3, 0xae, 0x84, 0x16, 0x45, 0x0a, 0xf4, 0xe5, 0x46, 0x26, 0x28, 0xf0,
	0x8e, 0xd8, 0x34, 0xde, 0xac, 0xb5, 0xa5, 0x9d, 0x65, 0x74, 0x71, 0xee, 0xfc, 0x2c, 0x01, 0xd0,
	0xdf, 0xef, 0x0f, 0xdc, 0xc9, 0x84, 0x24, 0xa1, 0x7c, 0x1f, 0x6c, 0xb3, 0xd4, 0xc3, 0xff, 0x24,
	0x52, 0xca, 0x45, 0x6e, 0xb0, 0xd4, 0xeb, 0xcf, 0xd3, 0x79, 0x1f, 0x6c, 0xfb, 0x8c, 0xe3, 0xab,
	0x47, 0xdc, 0xf0, 0x19, 0x9f, 0x9b, 0xfd, 0x31, 0x68, 0xb0, 0x73, 0x5f, 0x31, 0x9b, 0xe0, 0x71,
	0xc4, 0x30, 0x23, 0x61, 0xe2, 0xf2, 0x69, 0x1a, 0xe4, 0x63, 0x2f, 0xa3, 0x0d, 0xf6, 0x97, 0xf3,
	0x6a, 0xc4, 0xec, 0x73, 0xb8, 0xf3, 0x7d, 0x15, 0xdc, 0x9d, 0xd9, 0xca, 0x80, 0x84, 0xa9, 0xcb,
	0x09, 0x4d, 0xd4, 0xa9, 0x77, 0x14, 0xbc, 0xc9, 0x6a, 0xde, 0x05, 0x6b, 0x99, 0xf6, 0x49, 0x4a,
	0xe2, 0xa2, 0xff, 0x85, 0xe2, 0x15, 0x9f, 0xf1, 0xa1, 0x88, 0xdb, 0xc5, 0x98, 0x57, 0x99, 0xb4,
	0xf0, 0x9f, 0x4c, 0xaa, 0x5d, 0x6d, 0xd2, 0x03, 0xb0, 0x34, 0xce, 0x47, 0xca, 0xb8, 0xd7, 0xde,
	0xf4, 0x2a, 0x88, 0x14, 0xe8, 0x77, 0x7e, 0x90, 0xc0, 0x9a, 0x41, 0xbd, 0x72, 0x59, 0x79, 0x05,
	0x54, 0x2f, 0x96, 0x5b, 0x25, 0xff, 0xfa, 0x9a, 0xb6, 0xc0, 0xcd, 0xec, 0x8b, 0x16, 0xf8, 0x98,
	0x91, 0x67, 0x62, 0x63, 0x35, 0x04, 0x44, 0xc8, 0x26, 0xcf, 0x02, 0x79, 0x17, 0xac, 0x71, 0xca,
	0xdd, 0x08, 0x7b, 0x87, 0x6e, 0x1a, 0x06, 0x82, 0x56, 0xcb, 0x69, 0xab, 0x39, 0xa0, 0xe5, 0xf1,
	0x8c, 0xdb, 0xa1, 0xe0, 0x7f, 0x62, 0x77, 0x0f, 0x23, 0xfa, 0x14, 0xb9, 0x3c, 0x30, 0x48, 0x4c,
	0xb8, 0xfc, 0x29, 0x58, 0x7d, 0x12, 0xd1, 0xa7, 0x38, 0x75, 0x79, 0x80, 0xa3, 0x2c, 0x24, 0x16,
	0xa9, 0xbe, 0x57, 0xb8, 0x70, 0x5b, 0x4c, 0xcf, 0xfc, 0xa3, 0x3d, 0x42, 0xbb, 0xb1, 0xcb, 0x0f,
	0xf7, 0x60, 0x6e, 0x0b, 0x28, 0x6c, 0x81, 0xe7, 0xae, 0xdc, 0x7a, 0x32, 0x5b, 0xb9, 0xf3, 0xb5,
	0x04, 0xb6, 0xe6, 0x74, 0xb4, 0xb9, 0xcb, 0xa7, 0x2c, 0x93, 0x4e, 0x18, 0x2e, 0xac, 0xcf, 0xfb,
	0x06, 0xc2, 0xb1, 0x45, 0xb4, 0x4a, 0x98, 0xc8, 0x33, 0x44, 0x58, 0x56, 0xc0, 0xea, 0xc4, 0x3d,
	0x89, 0x83, 0x84, 0x63, 0xd7, 0xf7, 0xd3, 0x80, 0xb1, 0xdc, 0xb6, 0x25, 0x75, 0xf3, 0xd5, 0xf3,
	0x7b, 0xeb, 0x85, 0x0c, 0x45, 0x20, 0x36, 0x4f, 0x49, 0x12, 0xa2, 0x95, 0x22, 0xa1, 0x88, 0xee,
	0x7e, 0xb5, 0x00, 0x80, 0x4d, 0xa7, 0xa9, 0x17, 0x38, 0x27, 0x93, 0x40, 0xfe, 0x3f, 0x90, 0x6d,
	0x6b, 0x84, 0x34, 0x1d, 0x3b, 0x07, 0x43, 0x1d, 0x5b, 0x08, 0xf6, 0xa1, 0x59, 0xaf, 0xc8, 0x4d,
	0xd0, 0x98, 0x8d, 0x0f, 0x20, 0x42, 0x16, 0xc2, 0x43, 0xdd, 0xec, 0x41, 0xb3, 0x5f, 0x97, 0xe4,
	0x16, 0xd8, 0x9e, 0xc5, 0x55, 0x5b, 0xc3, 0x1a, 0xb2, 0x6c, 0x1b, 0x6b, 0x8f, 0x14, 0x68, 0xd6,
	0xab, 0x97, 0x0b, 0x58, 0xc3, 0x12, 0xbe, 0x20, 0xbf, 0x0d, 0x5a, 0xb3, 0xf8, 0xd0, 0x32, 0x0e,
	0xfa, 0x96, 0x59, 0x22, 0xd5, 0xe4, 0x0e, 0x68, 0xce, 0x92, 0x6c, 0x0d, 0x59, 0x86, 0x51, 0xe2,
	0x5c, 0x93, 0xef, 0x82, 0xb7, 0x66, 0x39, 0x06, 0x34, 0x75, 0xa5, 0x44, 0xb9, 0x7e, 0xb9, 0xcc,
	0x40, 0x31, 0x1d, 0x43, 0x2f, 0x71, 0x6e, 0xc8, 0xef, 0x80, 0xf6, 0x2c, 0x47, 0x41, 0x2a, 0x74,
	0xd0, 0x68, 0x50, 0x62, 0x2d, 0x5e, 0x66, 0x59, 0x43, 0x07, 0x0e, 0xa0, 0x5d, 0x66, 0x2d, 0xc9,
	0x6d, 0x70, 0xa7, 0x64, 0x8e, 0x62, 0x97, 0xbb, 0x81, 0x46, 0xed, 0xcb, 0xef, 0x9a, 0x95, 0xdd,
	0x08, 0x2c, 0x17, 0xbf, 0x22, 0xe2, 0x2a, 0x6c, 0x81, 0xdb, 0xea, 0x48, 0x7b, 0xac, 0x3b, 0xd8,
	0x76, 0x14, 0x67, 0x64, 0x63, 0x0d, 0xe9, 0x8a, 0xa3, 0xf7, 0xc4, 0x3e, 0xca, 0x50, 0x0f, 0xda,
	0x9a, 0x65, 0x3a, 0xd0, 0x1c, 0xe9, 0xbd, 0xba, 0x24, 0x6f, 0x83, 0x8d, 0x32, 0x3e, 0x80, 0x7d,
	0xa4, 0x38, 0xd9, 0xb2, 0xaa, 0x45, 0xb7, 0xc7, 0x60, 0x05, 0x05, 0xfe, 0x34, 0xf1, 0xdd, 0xc4,
	0x3b, 0x39, 0x5f, 0x3e, 0xd2, 0x7b, 0x23, 0xb3, 0xa7, 0x98, 0xda, 0x01, 0xd6, 0xb5, 0x5c, 0x6e,
	0xbd, 0x92, 0x15, 0x9b, 0x89, 0x23, 0x7d, 0x68, 0x40, 0x4d, 0x11, 0xa0, 0x54, 0x14, 0x23, 0x60,
	0xb9, 0x78, 0x37, 0x5d, 0x48, 0xb7, 0xd4, 0x4f, 0x74, 0x6d, 0x8e, 0xf4, 0x4d, 0xb0, 0x5e, 0x86,
	0x6c, 0x5d, 0x31, 0x72, 0xd1, 0x4d, 0xd0, 0x28, 0x23, 0xa5, 0xa1, 0xce, 0x75, 0x7f, 0x2b, 0x81,
	0x95, 0x7d, 0xc2, 0xc8, 0x98, 0x44, 0x84, 0x0b, 0xe1, 0x2d, 0xb0, 0xbd, 0x0f, 0x6d, 0xa8, 0x42,
	0x03, 0x3a, 0x07, 0xc2, 0xe4, 0x91, 0x69, 0x0f, 0x75, 0x0d, 0x3e, 0x84, 0x79, 0xcf, 0x39, 0x84,
	0xe1, 0x48, 0x35, 0xa0, 0x86, 0x91, 0xae, 0x14, 0x7e, 0xfd, 0x8d, 0x80, 0xe0, 0xbe, 0xe2, 0xe8,
	0xf5, 0xea, 0x3c, 0x10, 0x9a, 0x8f, 0x74, 0x04, 0x9d, 0xfa, 0x82, 0x10, 0xa5, 0xf6, 0x5e, 0x9c,
	0x36, 0xa5, 0x97, 0xa7, 0x4d, 0xe9, 0xf7, 0xd3, 0xa6, 0xf4, 0xcd, 0x59, 0xb3, 0xf2, 0xf2, 0xac,
	0x59, 0xf9, 0xf5, 0xac, 0x59, 0xf9, 0x6c, 0x37, 0x24, 0xfc, 0x70, 0x3a, 0xde, 0xf3, 0x68, 0xdc,
	0x0d, 0x8e, 0x63, 0xca, 0x8a, 0xe7, 0xf1, 0xfb, 0x1f, 0x74, 0xbf, 0xb8, 0xf8, 0x2b, 0xc1, 0x4f,
	0x26, 0x01, 0x1b, 0x5f, 0xcf, 0x5f, 0xfc, 0x1f, 0xfe, 0x19, 0x00, 0x00, 0xff, 0xff, 0x93, 0x9e,
	0x67, 0xbf, 0x67, 0x08, 0x00, 0x00,
}

func (m *SecondarySpSealObjectSignDoc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondarySpSealObjectSignDoc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondarySpSealObjectSignDoc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Checksum) > 0 {
		i -= len(m.Checksum)
		copy(dAtA[i:], m.Checksum)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Checksum)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.ObjectId.Size()
		i -= size
		if _, err := m.ObjectId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCommon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.GlobalVirtualGroupId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.GlobalVirtualGroupId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GVGMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GVGMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GVGMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SecondarySpBlsSignature) > 0 {
		i -= len(m.SecondarySpBlsSignature)
		copy(dAtA[i:], m.SecondarySpBlsSignature)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SecondarySpBlsSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DstGlobalVirtualGroupId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.DstGlobalVirtualGroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcGlobalVirtualGroupId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SrcGlobalVirtualGroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecondarySpMigrationBucketSignDoc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondarySpMigrationBucketSignDoc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondarySpMigrationBucketSignDoc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.BucketId.Size()
		i -= size
		if _, err := m.BucketId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCommon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.DstGlobalVirtualGroupId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.DstGlobalVirtualGroupId))
		i--
		dAtA[i] = 0x20
	}
	if m.SrcGlobalVirtualGroupId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SrcGlobalVirtualGroupId))
		i--
		dAtA[i] = 0x18
	}
	if m.DstPrimarySpId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.DstPrimarySpId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalVirtualGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalVirtualGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalVirtualGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalChargeSize != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.TotalChargeSize))
		i--
		dAtA[i] = 0x20
	}
	if m.StoredSize != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.StoredSize))
		i--
		dAtA[i] = 0x18
	}
	if m.GlobalVirtualGroupId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.GlobalVirtualGroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BucketFlowRateLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketFlowRateLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketFlowRateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FlowRateLimit.Size()
		i -= size
		if _, err := m.FlowRateLimit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCommon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BucketFlowRateLimitStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketFlowRateLimitStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketFlowRateLimitStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PaymentAddress) > 0 {
		i -= len(m.PaymentAddress)
		copy(dAtA[i:], m.PaymentAddress)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PaymentAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsBucketLimited {
		i--
		if m.IsBucketLimited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SecondarySpSealObjectSignDoc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.GlobalVirtualGroupId != 0 {
		n += 1 + sovCommon(uint64(m.GlobalVirtualGroupId))
	}
	l = m.ObjectId.Size()
	n += 1 + l + sovCommon(uint64(l))
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *GVGMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcGlobalVirtualGroupId != 0 {
		n += 1 + sovCommon(uint64(m.SrcGlobalVirtualGroupId))
	}
	if m.DstGlobalVirtualGroupId != 0 {
		n += 1 + sovCommon(uint64(m.DstGlobalVirtualGroupId))
	}
	l = len(m.SecondarySpBlsSignature)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *SecondarySpMigrationBucketSignDoc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.DstPrimarySpId != 0 {
		n += 1 + sovCommon(uint64(m.DstPrimarySpId))
	}
	if m.SrcGlobalVirtualGroupId != 0 {
		n += 1 + sovCommon(uint64(m.SrcGlobalVirtualGroupId))
	}
	if m.DstGlobalVirtualGroupId != 0 {
		n += 1 + sovCommon(uint64(m.DstGlobalVirtualGroupId))
	}
	l = m.BucketId.Size()
	n += 1 + l + sovCommon(uint64(l))
	return n
}

func (m *LocalVirtualGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.GlobalVirtualGroupId != 0 {
		n += 1 + sovCommon(uint64(m.GlobalVirtualGroupId))
	}
	if m.StoredSize != 0 {
		n += 1 + sovCommon(uint64(m.StoredSize))
	}
	if m.TotalChargeSize != 0 {
		n += 1 + sovCommon(uint64(m.TotalChargeSize))
	}
	return n
}

func (m *BucketFlowRateLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FlowRateLimit.Size()
	n += 1 + l + sovCommon(uint64(l))
	return n
}

func (m *BucketFlowRateLimitStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsBucketLimited {
		n += 2
	}
	l = len(m.PaymentAddress)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func sovCommon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecondarySpSealObjectSignDoc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondarySpSealObjectSignDoc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondarySpSealObjectSignDoc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalVirtualGroupId", wireType)
			}
			m.GlobalVirtualGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalVirtualGroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = append(m.Checksum[:0], dAtA[iNdEx:postIndex]...)
			if m.Checksum == nil {
				m.Checksum = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GVGMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GVGMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GVGMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcGlobalVirtualGroupId", wireType)
			}
			m.SrcGlobalVirtualGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcGlobalVirtualGroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstGlobalVirtualGroupId", wireType)
			}
			m.DstGlobalVirtualGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstGlobalVirtualGroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondarySpBlsSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondarySpBlsSignature = append(m.SecondarySpBlsSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.SecondarySpBlsSignature == nil {
				m.SecondarySpBlsSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondarySpMigrationBucketSignDoc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondarySpMigrationBucketSignDoc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondarySpMigrationBucketSignDoc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPrimarySpId", wireType)
			}
			m.DstPrimarySpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPrimarySpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcGlobalVirtualGroupId", wireType)
			}
			m.SrcGlobalVirtualGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcGlobalVirtualGroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstGlobalVirtualGroupId", wireType)
			}
			m.DstGlobalVirtualGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstGlobalVirtualGroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BucketId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalVirtualGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalVirtualGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalVirtualGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalVirtualGroupId", wireType)
			}
			m.GlobalVirtualGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalVirtualGroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredSize", wireType)
			}
			m.StoredSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoredSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalChargeSize", wireType)
			}
			m.TotalChargeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalChargeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketFlowRateLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketFlowRateLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketFlowRateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowRateLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FlowRateLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketFlowRateLimitStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketFlowRateLimitStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketFlowRateLimitStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBucketLimited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBucketLimited = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommon = fmt.Errorf("proto: unexpected end of group")
)
